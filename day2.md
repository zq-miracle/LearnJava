#数据类型转换：
	当数据类型不一样时，将会发生数据类型转换。
	##自动类型转换（隐式）
		1.特点：代码不需要进行特殊处理，自动完成。
		2.规则：数据范围从小到大。（long类型能自动转换成float类型，虽然long类型字节数比				   	  float多，但float范围比long大）
	##强制类型转换（显式）
		1.特点：代码需要进行特殊的格式处理，不能自动完成。
		2.格式：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据。例如： int num = (int) 100L;
	注意事项：
		1.强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出(必须保证逻辑上真是大小本来就没有超过short范围，否则会发生数据溢出)。
		2.byte/short/char这三种类型都可以发生数学运算，例如加法“+”。
			char zifu = 'A';
			result = zifu + 1;//66
			计算机的底层会用一个数字（二进制）来代表字符A，就是65。
			一旦char类型进行了数学运算，那么字符就会按照一定的规则翻译成为一个数字。
		3.byte/short/char这三种类型在运算的时候，都会被首先提升为int类型，然后再计算。
			byte num1 = 40；
			byte num2 = 50；
			byte result1  = num1 + num2；// 报错 
			//byte + byte  -->  int + int  -->  int
			int result2 = num1 + num2；// 90 
		4.boolean类型不能发生数据类型转换。

#编码表：
	数字和字符的对照关系表

	ASCII码表:American Standard Code for Information Interchange. 美国信息交换标准代码。
	Unicode码表：万国码。也是数字和字符的对照关系，开头0-127部分和ASCII完全一样，但是从128开始包含有更多字符。

	48 - '0'
	65 - 'A'
	97 - 'a'

#运算符：
	进行特定操作的符号。例如：+
	##表达式：
		用运算符连接起来的式子叫表达式。例如：20 + 5. 又例如 a + b

	四则运算：
	加：+
	减：-
	乘：*
	除：/
	取模（取余数）：%

	对于一个整数的表达式来说，除法用的是整除，整数除以整数，结果仍然是整数。只看商，不看余数。
	只有对于整数的除法来说，取模运算符才有余数的意义。

	注意事项：
		1.一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。例如：double result = 10 + 2.5  // int + double --> double + double -->double

	##四则运算当中的加号“+”有常见的三种用法：
		1.对于数值来说，那就是加法。
		2.对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。
		3.对于字符串String（首字母大写，并不是关键字）来说，加号代表字符串连接操作。
		任何数据类型和字符串进行连接的时候，结果都会变成字符串。
		
	##自增自减
		自增运算符：++		//让一个变量涨一个数字1
		自减运算符：--		//让一个变量降一个数字1
		
		###使用格式:
			1.单独使用：不和其他任何操作混合，自己独立成为一个步骤。
			2.混合使用：和其他操作混合，例如与赋值混合，或者与打印操作混合，等。
			####使用区别：
				1.在单独使用的时候，前++和后++没有任何区别。也就是：++num；和num++；是完全一样的。
				2.在混合的时候，有【重大区别】
					A，如果是【前++】，那么变量【立马+1】，然后拿着结果进行使用。
					B，如果是【后++】，那么首先使用变量本来的数值，【然后再让变量+1】。
		###注意事项：
			只有变量才能使用自增、自减运算符。常量不可能发生改变，所以不能使用。
			
	##赋值运算符
		###基本赋值运算符：就是一个等号“=”，代表将右侧的数据交给左侧的变量。 //int a = 30
		###复合赋值运算符：
			+=		a += 3		相当于		a = a + 3
			-=		b += 3		相当于		b = b - 3
			*=		c += 3		相当于		c = c * 3
			/=		d += 3		相当于		d = d / 3
			%=		e += 3		相当于		e = e % 3
		###注意事项：
			1.只有变量才能使用赋值运算符，常量不能进行赋值。
			2.复合赋值运算符其中隐含一个强制类型转换。 // byte a = 2; a += 3;(a:byte --> int)
	
	##比较运算符：
		大于：		>
		小于：		<
		大于等于： 	>=
		小于等于：	<=
		相等：		==
		不相等：	！=
		
		###注意事项：
			1.比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false
			2.如果进行多次判断，不能连着写。//例如：1 < x < 3
	
	##逻辑运算符:
		与（并且）	&&	全部是true，才是true；否则就是false
		或（或者）	||	至少一个是true，就是true；全都是false，才是false
		非（取反）	！	本来是true，编程false；本来是false，变成true
		
		与"&&","||",具有短路效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。
		
		###注意事项：
			1.逻辑运算符只能用于boolean值。
			2.与、或需要左右各自一个boolean值，但是取反只要有唯一一个boolean值即可。
			3.与、或两种运算符，如果有多个条件，可以连接写。
				两个条件：条件A && 条件B
				多个条件：条件A && 条件B && 条件C
			tips：
				对于1 < x <3的情况，应该拆成两个部分，然后使用与运算符连接起来：
				int x = 2;
				1 < x && x < 3
	
	##三元运算符：
		一元运算符：只需要一个数据就可以进行操作的运算符。例如；取反！、自增++、自减--
		二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=
		三元运算符：需要三个数据才可以进行操作的运算符。
		
		格式:
			数据类型 变量名称 = 条件判断 ？ 表达式A : 表达式B；
		流程：
			首先判断条件是否成立：
				如果成立为true，那么将表达式A的值赋值给左侧的变量。
				如果不成立为false，那么将表达式B的值赋值给左侧的变量；
			二者选其一。
			int max = a > b ? a : b; //最大值的变量：判断a > b是否成立，如果成立将a的值赋值给max；如果不成立将b的值赋值给max。
			
		###注意事项：
			1.必须同时保证表达式A和表达式B都符合左侧数据类型的要求。// int result = 3 > 4 ? 2.5 : 10; (错误写法：2.5为double类型)
			2.三元运算符的结果必须被使用。// 正确：System.out.println(a > b ? a : b); 错误：a > b ? a : b
			
#方法
	##定义一个方法的格式：
		public static void 方法名称(){
		方法体
		}
		###方法名称的命名规则和变量一样，使用小驼峰。
		###方法体：也就是大括号当中可以包含任意条语句。
	
	##注意事项：
		1.方法定义的先后顺序无所谓。
		2.方法的定义不能产生嵌套包含关系。
		3.方法定义好了之后，不会执行的。如果要执行，一定要进行方法的【调用】。
			
			###如何调用方法，格式：
				方法名称();

#jshell	
	当代码很简单，做一个简单的测试。懒得写。java文件 不想编译  运行...


#编译器的优化:

	对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，
	那么javac编译器将会自动隐含的为我们补上一个强转(byte)(short)(char)
	1.如果没有超过左侧的范围，编译器补上强转。	
	2.如果右侧超过了左侧范围，那么直接编译器报错。
	
	在给变量进行赋值的时候，如果右侧的表达式当中全是常量，没有任何变量，
	那么编译器javac将会直接将若干个常量表达式计算得到结果。
	short result = 5 + 8; // 等号右边全是常量，没有任何变量参与运算
	编译之后，得到的.class字节码文件当中相当于【直接就是】：short result = 13;
	右侧的常量结果数值，没有超过左侧范围，所以正确。
	
	这成为“编译器的常量优化”。
	但是注意：
		一旦表达式当中有变量参与，那么就不能进行这种优化了。
		short a =3;
		short result = 5 + a + 8; // 这是错误的。

		
	如果右边的数值在左边是数据类型范围内,就可以赋值。
		byte b = 10;  //可以
	如果计算是常量的时候,编辑器会自动计算结果。如果结果没有超出左边类型的范围,可以赋值。
		byte b = 30 + 40; //可以
	如果计算是变量的时候,编辑器不能计算,只能检查语法.发现大类型赋值给小类型是语法错误。编译失败！
		byte b = 10;
		byte b2 = b + 20;  //不可以
		
	
	
	
